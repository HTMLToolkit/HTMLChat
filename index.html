<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTMLChat</title>
  <!-- Favicon for browsers -->
  <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-512x512.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-512x512.png">
  
  <!-- Apple touch icon (iOS) -->
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-512x512.png">
  
  <!-- Manifest -->
  <link rel="manifest" href="manifest.json">
  <style>
       * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Trebuchet MS', Arial, sans-serif;
      background: #f0f0f0;
      color: #333;
      font-size: 16px;
    }

    .container {
      width: 90%;
      max-width: 1600px;
      margin: 20px auto;
      background: #fff;
      border: 2px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.774);
    }

    .header {
      background: linear-gradient(90deg, #2196F3, #21CBF3);
      color: white;
      padding: 12px 16px;
      font-weight: bold;
      font-size: 18px;
      border-bottom: 1px solid #0066cc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 18px;
      font-weight: bold;
    }

    .minimize-btn {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 20px;
      padding: 4px 8px;
      border-radius: 2px;
    }

    .minimize-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .toolbar {
      background: #e8e8e8;
      border-bottom: 1px solid #ccc;
      padding: 8px 12px;
      display: flex;
      gap: 15px;
      align-items: center;
      font-size: 14px;
    }

    .room-select {
      padding: 4px 6px;
      border: 1px inset #ccc;
      background: white;
      font-size: 14px;
      font-family: inherit;
    }

    .user-count {
      color: #666;
      margin-left: auto;
    }

    .main-content {
      display: flex;
      height: 600px;
    }

    .chat-area {
      display: flex;
      flex-direction: column;
      flex: 1 1 0;         /* Grow and shrink as needed */
      min-width: 300px;    /* Prevent it from becoming too narrow */
      max-width: calc(100% - 200px); /* Leave space for user list */
    }

    .chat-box {
      flex: 1;
      background: white;
      border-right: 1px solid #ccc;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.4;
    }

    .msg {
      padding: 4px 8px;
      border-bottom: 1px dotted #ddd;
    }

    .msg:hover {
      background: #f5f5f5;
    }

    .msg .time {
      color: #666;
      font-size: 12px;
    }

    .msg .user {
      font-weight: bold;
      margin-right: 6px;
    }

    .msg .text {
      margin-left: 6px;
    }

    .user-list {
      width: 180px;
      background: #f8f8f8;
      border-left: 1px solid #ccc;
      overflow-y: auto;
    }

    .user-list-header {
      background: #e0e0e0;
      padding: 6px 8px;
      font-size: 14px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
    }

    .user-item {
      padding: 4px 8px;
      font-size: 14px;
      border-bottom: 1px dotted #ddd;
    }

    .user-item:hover {
      background: #e8e8e8;
    }

    .input-area {
      border-top: 1px solid #ccc;
      padding: 8px;
      background: #f0f0f0;
    }

    .input-container {
      display: flex;
      gap: 6px;
    }

    .msg-input {
      flex: 1;
      padding: 6px 8px;
      border: 1px inset #ccc;
      font-size: 14px;
      font-family: inherit;
    }

    .send-btn {
      padding: 6px 16px;
      background: linear-gradient(90deg, #2196F3, #21CBF3);
      color: white;
      border: 1px outset #2196F3;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
    }

    .send-btn:active {
      border: 1px inset #2196F3;
    }

    .send-btn:disabled {
      background: #ccc;
      border: 1px outset #ccc;
      cursor: not-allowed;
    }

    .status-bar {
      background: #e8e8e8;
      border-top: 1px solid #ccc;
      padding: 4px 8px;
      font-size: 12px;
      color: #666;
      display: flex;
      justify-content: space-between;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #00cc00;
    }

    .status-dot.disconnected {
      background: #cc0000;
    }

    /* Scrollbar styling for retro feel */
    .chat-box::-webkit-scrollbar,
    .user-list::-webkit-scrollbar {
      width: 16px;
    }

    .chat-box::-webkit-scrollbar-track,
    .user-list::-webkit-scrollbar-track {
      background: #f0f0f0;
      border: 1px inset #ccc;
    }

    .chat-box::-webkit-scrollbar-thumb,
    .user-list::-webkit-scrollbar-thumb {
      background: linear-gradient(90deg, #2196F3, #21CBF3);
      border: 1px outset #2196F3;
    }

    .chat-box::-webkit-scrollbar-button,
    .user-list::-webkit-scrollbar-button {
      background: #e0e0e0;
      border: 1px outset #ccc;
      height: 16px;
    }

    /* Mobile responsiveness */
    @media (max-width: 640px) {
      .container {
        margin: 10px;
        max-width: none;
      }
      
      .main-content {
        height: 500px;
      }
      
      .user-list {
        display: none;
      }
      
      .toolbar {
        flex-wrap: wrap;
        gap: 8px;
      }
      .chat-area {
        max-width: 100%;
        min-width: 100%;
      }
    }

    /* System message styling */
    .msg.system {
      background: #fff3cd;
      border-left: 3px solid #ffc107;
    }

    .msg.system .user {
      color: #856404;
    }

    /* Welcome message */
    .welcome {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      padding: 10px;
      margin: 6px;
      font-size: 14px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>HTMLChat</h1>
      <p>version v0.1.0</p>
      <button class="minimize-btn" onclick="window.close()">×</button>
    </div>

    <div class="toolbar">
      <label for="room-select">Room:</label>
      <select id="room-select" class="room-select">
        <option value="default">#general</option>
        <option value="fun">#random</option>
        <option value="random">#offtopic</option>
        <option value="tech">#computers</option>
      </select>
      <span class="user-count">Users online: <span id="user-count">1</span></span>
    </div>

    <div id="welcome" class="welcome"></div>

    <div class="main-content">
      <div class="chat-area">
        <div id="chat" class="chat-box"></div>
        <div class="input-area">
          <div id="chat-form" class="input-container">
            <input id="msg" class="msg-input" placeholder="Type message here..." maxlength="1000" />
            <button type="button" class="send-btn" id="send-btn">Send</button>
          </div>
        </div>
      </div>
      
      <div class="user-list">
        <div class="user-list-header">Users</div>
        <div id="users"></div>
      </div>
    </div>

    <div class="status-bar">
      <div class="connection-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">Connected</span>
      </div>
      <div>
        <button onclick="exportChat()" style="background:none;border:none;color:#666;cursor:pointer;font-size:10px;">Export</button>
      </div>
    </div>
  </div>

  <!-- External dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.5/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <script>
    // Global variables
    let refreshTimer = null;
    let isVisible = !document.hidden;
    let lastActivity = Date.now();
    let lastMessageTime = 0;
    let lastFetchTime = 0;

    function processText(text) {
      // 1. Convert Markdown to HTML
      let html = marked.parse(text);
  
      // 2. Sanitize the HTML to prevent XSS
      html = DOMPurify.sanitize(html, {
        ALLOWED_TAGS: [
          'b','i','em','strong','u','a','p','ul','ol','li','code',
          'pre','img','h1','h2','h3','h4','h5','h6','br','span','div'
        ],
        ALLOWED_ATTR: ['href','src','alt','title','target','style']
      });
  
      // 3. convert remaining plain URLs (not inside tags) into clickable links
      html = html.replace(/(?<!["'>])\bhttps?:\/\/[^\s<]+/g, '<a href="$&" target="_blank" style="color:#0066cc">$&</a>');
  
      return html;
    }
    
    // Simple color assignment
    const userColors = [
      '#cc0000', '#00cc00', '#0000cc', '#cc6600', '#cc00cc', 
      '#006666', '#990099', '#009900', '#990000', '#000099'
    ];

    function getUserColor(user) {
      let hash = 0;
      for (let i = 0; i < user.length; i++) {
        hash = user.charCodeAt(i) + ((hash << 5) - hash);
      }
      return userColors[Math.abs(hash) % userColors.length];
    }

    // Simple storage
    function saveToStorage(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch(e) {
        console.warn("Storage failed:", e);
      }
    }

    function loadFromStorage(key) {
      try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : null;
      } catch(e) {
        console.warn("Load failed:", e);
        return null;
      }
    }

    // Message rendering
    function renderMessages(messages) {
      if (!Array.isArray(messages)) {
        console.error('renderMessages expects an array, got:', typeof messages);
        return '<div class="msg system"><span class="time">[--:--]</span><span class="user">*** System ***</span><span class="text">Error loading messages.</span></div>';
      }

      return messages.map(({ user, text, time }) => {
        const color = getUserColor(user);
        const date = new Date(time).toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        const processedText = processText(text);
        
        return `
          <div class="msg">
            <span class="time">[${date}]</span>
            <span class="user" style="color:${color}">&lt;${user}&gt;</span>
            <span class="text">${processedText}</span>
          </div>
        `;
      }).join('');
    }

    function scrollToBottom() {
      const chatBox = document.getElementById("chat");
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    function updateStatus(connected) {
      const dot = document.getElementById("status-dot");
      const text = document.getElementById("status-text");
      
      if (connected) {
        dot.className = "status-dot";
        text.textContent = "Connected";
      } else {
        dot.className = "status-dot disconnected";
        text.textContent = "Disconnected";
      }
    }

    function exportChat() {
      const messages = loadFromStorage("htmlchat_messages") || [];
      if (messages.length === 0) {
        alert("No messages to export.");
        return;
      }

      const exportData = {
        room: document.getElementById("room-select").value,
        exported: new Date().toISOString(),
        messages: messages
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: "application/json"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `htmlchat-export-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Main application
    (function() {
      let user = loadFromStorage("htmlchat_user");
      if (!user) {
        do {
          user = prompt("Enter your nickname:") || "";
          user = user.trim().substring(0, 20);
        } while (!user);
        saveToStorage("htmlchat_user", user);
      }

      const roomSelect = document.getElementById("room-select");
      const welcomeDiv = document.getElementById("welcome");
      const chatBox = document.getElementById("chat");
      const inputContainer = document.getElementById("chat-form");
      const input = document.getElementById("msg");
      const sendBtn = document.getElementById("send-btn");
      const usersDiv = document.getElementById("users");

      const savedRoom = loadFromStorage("htmlchat_room") || "default";
      roomSelect.value = savedRoom;

      const baseURL = "https://htmlchat.neeljaiswal23.workers.dev";

      function updateWelcome() {
        welcomeDiv.innerHTML = `Welcome to HTMLChat, <b>${user}</b>! You are now in room <b>${roomSelect.value}</b>.`;
      }

      updateWelcome();

      // Update user list with real data from server
      function updateUserList(users = null, userCount = null) {
        if (users && Array.isArray(users)) {
          document.getElementById("user-count").textContent = userCount || users.length;
          usersDiv.innerHTML = users.map(u => 
            `<div class="user-item" style="color:${getUserColor(u)}">${u}</div>`
          ).join('');
        } else {
          // Fallback to fake users
          const fakeUsers = [user, "ChatBot", "Guest123"];
          document.getElementById("user-count").textContent = fakeUsers.length;
          usersDiv.innerHTML = fakeUsers.map(u => 
            `<div class="user-item" style="color:${getUserColor(u)}">${u}</div>`
          ).join('');
        }
      }

      updateUserList();

      async function fetchMessages(forceRefresh = false) {
        try {
          if (!forceRefresh) {
            const cached = loadFromStorage(`htmlchat_${roomSelect.value}`);
            if (cached && Array.isArray(cached)) {
              chatBox.innerHTML = renderMessages(cached);
              scrollToBottom();
            }
          }

          const res = await fetch(`${baseURL}/chat/${roomSelect.value}`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          
          const data = await res.json();
          console.log('Received data:', data); // Debug log
          
          // Extract messages array from the response object
          const messages = data.messages || [];
          const users = data.users || [];
          const userCount = data.userCount || users.length;
          
          chatBox.innerHTML = renderMessages(messages);
          scrollToBottom();
          
          // Update user list with real data
          updateUserList(users, userCount);
          
          saveToStorage(`htmlchat_${roomSelect.value}`, messages);
          saveToStorage("htmlchat_messages", messages);
          updateStatus(true);
        } catch(e) {
          console.error("Fetch failed:", e);
          updateStatus(false);
          
          if (chatBox.innerHTML === '') {
            chatBox.innerHTML = `
              <div class="msg system">
                <span class="time">[--:--]</span>
                <span class="user">*** System ***</span>
                <span class="text">Unable to connect to server. Please check your connection.</span>
              </div>
            `;
          }
        }
      }

      // Send message function
      async function sendMessage() {
        const messageText = input.value.trim();
        if (!messageText) return;

        sendBtn.disabled = true;
        sendBtn.textContent = "...";

        try {
          const room = roomSelect.value;
          const res = await fetch(`${baseURL}/chat/${room}?user=${encodeURIComponent(user)}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: messageText }),
          });
          
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          
          input.value = "";
          
          // Immediately fetch new messages after sending
          await fetchMessages(true);
          
          // Reset refresh interval since we're active
          scheduleNextRefresh(15000); // 15 seconds after sending
          
        } catch(e) {
          console.error("Send failed:", e);
          alert("Message failed to send. Please try again.");
          updateStatus(false);
        } finally {
          sendBtn.disabled = false;
          sendBtn.textContent = "Send";
          input.focus();
        }
      }

      // Event listeners for sending messages
      sendBtn.addEventListener('click', sendMessage);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      roomSelect.onchange = async () => {
        // Clear current timers
        if (refreshTimer) {
          clearTimeout(refreshTimer);
        }
        
        // Leave current room (only if we were in a different room)
        const oldRoom = loadFromStorage("htmlchat_room") || "default";
        if (oldRoom !== roomSelect.value) {
          try {
            await fetch(`${baseURL}/chat/${oldRoom}?user=${encodeURIComponent(user)}`, {
              method: "DELETE"
            });
          } catch(e) {
            console.warn("Failed to leave room:", e);
          }
        }
        
        saveToStorage("htmlchat_room", roomSelect.value);
        updateWelcome();
        chatBox.innerHTML = '<div class="msg system"><span class="time">[--:--]</span><span class="user">*** System ***</span><span class="text">Loading messages...</span></div>';
        
        // Reset tracking variables
        lastMessageTime = 0;
        lastFetchTime = 0;
        
        await fetchMessages(true);
        scheduleNextRefresh(15000); // Start fresh interval
      };

      // Smart refresh scheduling based on activity
      function scheduleNextRefresh(delay = 20000) { // Default 20 seconds
        if (refreshTimer) {
          clearTimeout(refreshTimer);
        }
        
        // Adjust delay based on visibility and activity
        if (!isVisible) {
          delay = Math.min(delay * 3, 60000); // Max 1 minute when not visible
        }
        
        refreshTimer = setTimeout(async () => {
          await fetchMessages();
          scheduleNextRefresh(isVisible ? 20000 : 45000); // 20s visible, 45s hidden
        }, delay);
      }

      // Page visibility handling to reduce calls when tab is hidden
      document.addEventListener('visibilitychange', () => {
        isVisible = !document.hidden;
        
        if (isVisible) {
          // When tab becomes visible, fetch immediately then schedule normal refresh
          fetchMessages(true);
          scheduleNextRefresh(15000);
        } else {
          // When tab is hidden, slow down refresh rate
          scheduleNextRefresh(60000); // 1 minute when hidden
        }
      });

      // Heartbeat function
      async function sendHeartbeat() {
        try {
          await fetch(`${baseURL}/chat/${roomSelect.value}?user=${encodeURIComponent(user)}`, {
            method: "PUT"
          });
        } catch(e) {
          console.warn("Heartbeat failed:", e);
        }
      }

      // Heartbeat only every 2 minutes (much less frequent) and only when active
      function scheduleHeartbeat() {
        setTimeout(async () => {
          // Only send heartbeat if user has been active in last 5 minutes AND tab is visible
          const timeSinceActivity = Date.now() - lastActivity;
          if (isVisible && timeSinceActivity < 300000) { // 5 minutes
            await sendHeartbeat();
          }
          scheduleHeartbeat();
        }, 120000); // Every 2 minutes
      }

      // Manual refresh button (add this to reduce automatic calls)
      function addRefreshButton() {
        const refreshBtn = document.createElement('button');
        refreshBtn.textContent = '↻';
        refreshBtn.style.cssText = 'background:none;border:none;color:#666;cursor:pointer;font-size:14px;margin-left:10px;';
        refreshBtn.title = 'Refresh messages';
        refreshBtn.onclick = () => fetchMessages(true);
        document.querySelector('.status-bar .connection-status').appendChild(refreshBtn);
      }

      // Leave room when page is closed/refreshed
      window.addEventListener('beforeunload', () => {
        const url = `${baseURL}/chat/${roomSelect.value}?user=${encodeURIComponent(user)}`;
        try {
          navigator.sendBeacon(url, JSON.stringify({ method: 'DELETE' }));
        } catch(e) {
          // Fallback for browsers that don't support sendBeacon
          fetch(url, { method: 'DELETE', keepalive: true }).catch(() => {});
        }
      });

      // Focus events to detect user activity
      ['click', 'keypress', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, () => {
          lastActivity = Date.now();
        }, { passive: true });
      });

      // Initial load
      fetchMessages(true);
      addRefreshButton();
      scheduleNextRefresh(15000); // Start with 15 second interval
      setTimeout(() => scheduleHeartbeat(), 60000); // First heartbeat after 1 minute
      input.focus();

      // Enter key focus
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && document.activeElement !== input && e.target.tagName !== 'BUTTON') {
          input.focus();
        }
      });
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>
    eruda.init();
  </script>
</body>
</html>
